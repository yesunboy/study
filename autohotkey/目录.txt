第1章 java语言概述	1
1.1 java语言的发展简史	2
1.2 java的竞争对手及各自优势	4
1.2.1 c#简介和优势	4
1.2.2 ruby简介和优势	5
1.2.3 python简介和优势	5
1.3 java程序运行机制	6
1.3.1 高级语言的运行机制	6
1.3.2 java程序的运行机制和jvm	6
1.4 开发java的准备	7
1.4.1 下载和安装java 7的jdk	8
不是说jvm是运行java程序的虚拟机吗？那jre和jvm的关系是怎样的呢？	8
为什么不安装公共jre呢？	9
1.4.2 设置path环境变量	10
为什么选择用户变量？用户变量与系统变量有什么区别？	11
1.5 第一个java程序	11
1.5.1 编辑java源代码	11
1.5.2 编译java程序	12
当我们编译c程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译java程序时怎么不需要指定目标文件的文件名呢？	12
1.5.3 运行java程序	13
1.5.4 根据classpath环境变量定位类	14
1.6 java程序的基本规则	15
1.6.1 java程序的组织形式	15
1.6.2 java源文件的命名规则	15
1.6.3 初学者容易犯的错误	16
1.7 垃圾回收机制	18
1.8 何时开始使用ide工具	19
我想学习java编程，到底是学习eclipse好呢，还是学习netbeans好呢？	20
1.9 本章小结	20
本章练习	20
第2章 理解面向对象	21
2.1 面向对象	22
2.1.1 结构化程序设计简介	22
2.1.2 程序的三种基本结构	23
2.1.3 面向对象程序设计简介	25
2.1.4 面向对象的基本特征	26
2.2 uml(统一建模语言)介绍	27
2.2.1 用例图	29
2.2.2 类图	29
2.2.3 组件图	31
2.2.4 部署图	32
2.2.5 顺序图	32
2.2.6 活动图	33
2.2.7 状态机图	34
2.3 java的面向对象特征	35
2.3.1 一切都是对象	35
2.3.2 类和对象	35
2.4 本章小结	36
第3章 数据类型和运算符	37
3.1 注释	38
3.1.1 单行注释和多行注释	38
3.1.2 文档注释	39
api文档是什么?	39
为什么要掌握查看api文档的方法？	41
3.2 标识符和关键字	45
3.2.1 分隔符	45
3.2.2 标识符规则	46
3.2.3 java关键字	46
3.3 数据类型分类	47
3.4 基本数据类型	47
3.4.1 整型	48
3.4.2 java 7新增的二进制整数	49
3.4.3 字符型	50
3.4.4 浮点型	51
3.4.5 java 7新增的数值中使用下画线分隔	52
3.4.6 布尔型	52
3.5 基本类型的类型转换	53
3.5.1 自动类型转换	53
3.5.2 强制类型转换	54
3.5.3 表达式类型的自动提升	56
3.6 直接量	57
3.6.1 直接量的类型	57
3.6.2 直接量的赋值	57
3.7 运算符	58
3.7.1 算术运算符	58
3.7.2 赋值运算符	61
3.7.3 位运算符	61
3.7.4 扩展后的赋值运算符	64
3.7.5 比较运算符	65
3.7.6 逻辑运算符	66
3.7.7 三目运算符	66
3.7.8 运算符的结合性和优先级	67
3.8 本章小结	68
本章练习	68
第4章 流程控制与数组	70
4.1 顺序结构	71
4.2 分支结构	71
4.2.1 if条件语句	71
4.2.2 java 7的switch分支语句	75
4.3 循环结构	77
4.3.1 while循环语句	77
4.3.2 do while循环语句	78
4.3.3 for循环	79
4.3.4 嵌套循环	81
4.4 控制循环结构	83
4.4.1 使用break结束循环	83
4.4.2 使用continue结束本次循环	84
4.4.3 使用return结束方法	85
4.5 数组类型	86
4.5.1 理解数组：数组也是一种类型	86
int[]是一种类型吗？怎么使用这种类型呢？	86
4.5.2 定义数组	86
4.5.3 数组的初始化	87
能不能只分配内存空间，不赋初始值呢？	87
4.5.4 使用数组	88
为什么要我记住这些异常信息？	89
4.5.5 foreach循环	89
4.6 深入数组	91
4.6.1 内存中的数组	91
为什么有栈内存和堆内存之分？	91
4.6.2 基本类型数组的初始化	93
4.6.3 引用类型数组的初始化	94
4.6.4 没有多维数组	96
我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组？这样不就可以扩展成三维数组吗？甚至扩展成更多维的数组？	98
4.6.5 操作数组的工具类	99
4.6.6 数组的应用举例	101
4.7 本章小结	104
本章练习	104
第5章 面向对象(上)	105
5.1 类和对象	106
5.1.1 定义类	106
构造器不是没有返回值吗？为什么不能用void修饰呢？	108
5.1.2 对象的产生和使用	108
5.1.3 对象、引用和指针	109
5.1.4 对象的this引用	110
5.2 方法详解	114
5.2.1 方法的所属性	114
5.2.2 方法的参数传递机制	115
5.2.3 形参个数可变的方法	118
5.2.4 递归方法	119
5.2.5 方法重载	121
为什么方法的返回值类型不能用于区分重载的方法？	121
5.3 成员变量和局部变量	122
5.3.1 成员变量和局部变量	122
5.3.2 成员变量的初始化和内存中的运行机制	125
5.3.3 局部变量的初始化和内存中的运行机制	127
5.3.4 变量的使用规则	128
5.4 隐藏和封装	129
5.4.1 理解封装	129
5.4.2 使用访问控制符	129
5.4.3 package、import和import static	132
5.4.4 java的常用包	137
5.5 深入构造器	137
5.5.1 使用构造器执行初始化	138
构造器是创建java对象的途径，是不是说构造器完全负责创建java对象？	138
5.5.2 构造器重载	139
为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？	140
5.6 类的继承	140
5.6.1 继承的特点	141
5.6.2 重写父类的方法	142
5.6.3 super限定	143
5.6.4 调用父类构造器	146
为什么我创建java对象时从未感觉到java.lang. object类的构造器被调用过？	148
5.7 多态	148
5.7.1 多态性	148
5.7.2 引用变量的强制类型转换	149
5.7.3 instanceof运算符	151
5.8 继承与组合	151
5.8.1 使用继承的注意点	151
5.8.2 利用组合实现复用	153
使用组合关系来实现复用时，需要创建两个animal对象，是不是意味着使用组合关系时系统开销更大？	155
5.9 初始化块	156
5.9.1 使用初始化块	156
5.9.2 初始化块和构造器	157
5.9.3 静态初始化块	158
5.10 本章小结	160
本章练习	161
第6章 面向对象(下)	162
6.1 java 7增强的包装类	163
java为什么要对这些数据进行缓存呢?	166
6.2 处理对象	167
6.2.1 打印对象和tostring方法	167
6.2.2 ==和equals方法	168
判断obj是否为person类的实例时，为何不用obj instanceof person来判断呢？	172
6.3 类成员	172
6.3.1 理解类成员	172
6.3.2 单例(singleton)类	173
6.4 final修饰符	174
6.4.1 final成员变量	174
6.4.2 final局部变量	176
6.4.3 final修饰基本类型变量和引用类型变量的区别	177
6.4.4 可执行“宏替换”的final变量	177
6.4.5 final方法	179
6.4.6 final类	180
6.4.7 不可变类	180
6.4.8 缓存实例的不可变类	183
6.5 抽象类	186
6.5.1 抽象方法和抽象类	186
6.5.2 抽象类的作用	189
6.6 更彻底的抽象：接口	190
6.6.1 接口的概念	190
6.6.2 接口的定义	191
6.6.3 接口的继承	192
6.6.4 使用接口	193
6.6.5 接口和抽象类	194
6.6.6 面向接口编程	195
6.7 内部类	199
6.7.1 非静态内部类	199
非静态内部类对象和外部类对象的关系是怎样的？	202
6.7.2 静态内部类	203
为什么静态内部类的实例方法也不能访问外部类的实例属性呢？	204
接口里是否能定义内部接口？	205
6.7.3 使用内部类	205
既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类？	207
6.7.4 局部内部类	207
6.7.5 匿名内部类	208
6.7.6 闭包(closure)和回调	211
6.8 枚举类	213
6.8.1 手动实现枚举类	213
6.8.2 枚举类入门	215
6.8.3 枚举类的field、方法和构造器	216
6.8.4 实现接口的枚举类	218
枚举类不是用final修饰了吗？怎么还能派生子类呢？	207
6.8.5 包含抽象方法的枚举类	220
6.9 对象与垃圾回收	221
6.9.1 对象在内存中的状态	221
6.9.2 强制垃圾回收	222
6.9.3 finalize方法	223
6.9.4 对象的软、弱和虚引用	225
6.10 修饰符的适用范围	228
6.11 使用jar文件	229
6.11.1 jar命令详解	230
6.11.2 创建可执行的jar包	232
6.11.3 关于jar包的技巧	232
6.12 本章小结	233
本章练习	233
第7章 与运行环境交互	234
7.1 与用户互动	235
7.1.1 运行java程序的参数	235
7.1.2 使用scanner获取键盘输入	236
7.1.3 使用bufferedreader获取键盘输入	238
7.2 系统相关	238
7.2.1 system类	239
7.2.2 runtime类	240
7.3 常用类	241
7.3.1 object类	241
7.3.2 java 7新增的objects类	243
7.3.3 string、stringbuffer和stringbuilder类	244
7.3.4 math类	247
7.3.5 java 7的threadlocalrandom与random	248
7.3.6 bigdecimal类	250
7.4 处理日期的类	253
7.4.1 date类	253
7.4.2 calendar类	254
7.4.3 timezone类	257
7.5 正则表达式	258
7.5.1 创建正则表达式	258
7.5.2 使用正则表达式	261
7.6 国际化与格式化	264
7.6.1 java国际化的思路	265
7.6.2 java支持的国家和语言	265
7.6.3 完成程序国际化	266
7.6.4 使用messageformat处理包含占位符的字符串	267
7.6.5 使用类文件代替资源文件	268
7.6.6 使用numberformat格式化数字	269
7.6.7 使用dateformat格式化日期、时间	270
7.6.8 使用simpledateformat格式化日期	272
7.7 本章小结	273
本章练习	273
第8章 java集合	274
8.1 java集合概述	275
8.2 collection和iterator接口	276
8.2.1 使用iterator接口遍历集合元素	278
8.2.2 使用foreach循环遍历集合元素	280
8.3 set集合	280
8.3.1 hashset类	281
hashcode()方法对于hashset是不是十分重要？	283
8.3.2 linkedhashset类	285
8.3.3 treeset类	286
8.3.4 enumset类	292
8.3.5 各set实现类的性能分析	293
8.4 list集合	294
8.4.1 list接口和listiterator接口	294
8.4.2 arraylist和vector实现类	297
8.4.3 固定长度的list	298
8.5 queue集合	298
8.5.1 priorityqueue实现类	299
8.5.2 deque接口与arraydeque实现类	300
8.5.3 linkedlist实现类	301
8.5.4 各种线性表的性能分析	302
8.6 map	303
8.6.1 hashmap和hashtable实现类	304
8.6.2 linkedhashmap实现类	308
8.6.3 使用properties读写属性文件	308
8.6.4 sortedmap接口和treemap实现类	309
8.6.5 weakhashmap实现类	311
8.6.6 identityhashmap实现类	312
8.6.7 enummap实现类	313
8.6.8 各map实现类的性能分析	314
8.7 hashset和hashmap的性能选项	314
8.8 操作集合的工具类：collections	315
8.8.1 排序操作	315
8.8.2 查找、替换操作	318
8.8.3 同步控制	319
8.8.4 设置不可变集合	320
8.9 烦琐的接口：enumeration	320
8.10 本章小结	321
本章练习	321
第9章 泛型	322
9.1 泛型入门	323
9.1.1 编译时不检查类型的异常	323
9.1.2 手动实现编译时检查类型	324
9.1.3 使用泛型	324
9.1.4 java 7泛型的“菱形”语法	325
9.2 深入泛型	326
9.2.1 定义泛型接口、类	326
9.2.2 从泛型类派生子类	328
9.2.3 并不存在泛型类	329
9.3 类型通配符	329
9.3.1 使用类型通配符	331
9.3.2 设定类型通配符的上限	332
9.3.3 设定类型形参的上限	333
9.4 泛型方法	334
9.4.1 定义泛型方法	334
9.4.2 泛型方法和类型通配符的区别	337
9.4.3 java 7的“菱形”语法与泛型构造器	338
9.4.4 设定通配符下限	339
9.4.5 泛型方法与方法重载	341
9.5 擦除和转换	341
9.6 泛型与数组	343
9.7 本章小结	344
第10章 异常处理	345
10.1 异常概述	346
10.2 异常处理机制	347
10.2.1 使用try...catch捕获异常	347
10.2.2 异常类的继承体系	349
10.2.3 java 7提供的多异常捕获	351
10.2.4 访问异常信息	352
10.2.5 使用finally回收资源	353
10.2.6 异常处理的嵌套	355
10.2.7 java 7的自动关闭资源的try语句	355
10.3 checked异常和runtime异常体系	357
10.3.1 使用throws声明抛出异常	357
10.4 使用throw抛出异常	359
10.4.1 抛出异常	359
10.4.2 自定义异常类	360
10.4.3 catch和throw同时使用	361
10.4.4 java 7增强的throw语句	362
10.4.5 异常链	363
10.5 java的异常跟踪栈	365
10.6 异常处理规则	366
10.6.1 不要过度使用异常	367
10.6.2 不要使用过于庞大的try块	368
10.6.3 避免使用catch all语句	368
10.6.4 不要忽略捕获到的异常	368
10.7 本章小结	369
本章练习	369
第11章 awt编程	370
11.1 gui(图形用户界面)和awt	371
11.2 awt容器	372
11.3 布局管理器	375
11.3.1 flowlayout布局管理器	375
11.3.2 borderlayout布局管理器	376
borderlayout最多只能放置5个组件吗？那它也太不实用了吧？	377
11.3.3 gridlayout布局管理器	378
11.3.4 gridbaglayout布局管理器	379
11.3.5 cardlayout布局管理器	381
11.3.6 绝对定位	383
11.3.7 boxlayout布局管理器	384
图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像flowlayout、gridlayout等布局管理器那样指定组件的间距应该怎么办？	385
11.4 awt常用组件	386
11.4.1 基本组件	386
11.4.2 对话框(dialog)	388
11.5 事件处理	390
11.5.1 java事件模型的流程	390
11.5.2 事件和事件监听器	392
11.5.3 事件适配器	396
11.5.4 使用内部类实现监听器	397
11.5.5 使用外部类实现监听器	397
11.5.6 类本身作为事件监听器类	398
11.5.7 匿名内部类实现监听器	399
11.6 awt菜单	399
11.6.1 菜单条、菜单和菜单项	399
11.6.2 右键菜单	401
为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时也一样会弹出右键菜单？	403
11.7 在awt中绘图	403
11.7.1 画图的实现原理	403
11.7.2 使用graphics类	404
11.8 处理位图	408
11.8.1 image抽象类和bufferedimage实现类	408
11.8.2 使用imageio输入/输出位图	411
11.9 剪贴板	414
11.9.1 数据传递的类和接口	415
11.9.2 传递文本	415
11.9.3 使用系统剪贴板传递图像	417
11.9.4 使用本地剪贴板传递对象引用	421
11.9.5 通过系统剪贴板传递java对象	423
11.10 拖放功能	426
11.10.1 拖放目标	427
11.10.2 拖放源	429
11.11 本章小结	431
本章练习	431
第12章 swing编程	432
12.1 swing概述	433
12.2 swing基本组件的用法	434
12.2.1 java 7 的swing组件层次	434
12.2.2 awt组件的swing实现	435
为什么单击swing多行文本域时不是弹出像awt多行文本域中的右键菜单？	441
12.2.3 为组件设置边框	441
12.2.4 swing组件的双缓冲和键盘驱动	443
12.2.5 使用jtoolbar创建工具条	444
12.2.6 使用jfilechooser和java 7增强的jcolorchooser	446
12.2.7 使用joptionpane	454
12.3 swing中的特殊容器	459
12.3.1 使用jsplitpane	459
12.3.2 使用jtabbedpane	461
12.3.3 使用jlayeredpane、jdesktoppane和jinternalframe	464
12.4 swing简化的拖放功能	472
12.5 java 7新增的swing功能	473
12.5.1 使用jlayer装饰组件	473
12.5.2 创建透明、不规则形状窗口	479
12.6 使用jprogressbar、progressmonitor和boundedrangemodel创建进度条	481
12.6.1 创建进度条	482
12.6.2 创建进度对话框	485
12.7 使用jslider和boundedrangemodel创建滑动条	486
12.8 使用jspinner和spinnermodel创建微调控制器	489
12.9 使用jlist、jcombobox创建列表框	492
12.9.1 简单列表框	493
12.9.2 不强制存储列表项的listmodel和comboboxmodel	496
12.9.3 强制存储列表项的defaultlistmodel和 defaultcomboboxmodel	499
为什么jcombobox提供了添加、删除列表项的方法？而jlist没有提供添加、删除列表项的方法呢？	510
12.9.4 使用listcellrenderer改变列表项外观	501
12.10 使用jtree和treemodel创建树	503
12.10.1 创建树	504
12.10.2 拖动、编辑树节点	507
12.10.3 监听节点事件	511
12.10.4 使用defaulttreecellrenderer改变节点外观	512
12.10.5 扩展defaulttreecellrenderer改变节点外观	514
12.10.6 实现treecellrenderer改变节点外观	516
12.11 使用jtable和tablemodel创建表格	518
12.11.1 创建表格	518
我们指定的表格数据、表格列标题都是object类型的数组，jtable如何显示这些object对象？	519
12.11.2 tablemodel和监听器	524
12.11.3 tablecolumnmodel和监听器	528
12.11.4 实现排序	531
12.11.5 绘制单元格内容	534
12.11.6 编辑单元格内容	537
12.12 使用jformattedtextfield和jtextpane创建格式文本	541
12.12.1 监听document的变化	541
12.12.2 使用jpasswordfield	543
12.12.3 使用jformattedtextfield	544
12.12.4 使用jeditorpane	552
12.12.5 使用jtextpane	552
12.13 本章小结	559
本章练习	559
第13章 mysql数据库与jdbc编程	560
13.1 jdbc基础	561
13.1.1 jdbc简介	561
13.1.2 jdbc驱动程序	562
13.2 sql语法	563
13.2.1 安装数据库	563
13.2.2 关系数据库基本概念和mysql基本命令	565
13.2.3 sql语句基础	567
13.2.4 ddl语句	568
13.2.5 数据库约束	572
13.2.6 索引	579
13.2.7 视图	579
13.2.8 dml语句语法	580
13.2.9 单表查询	583
13.2.10 数据库函数	587
13.2.11 分组和组函数	589
13.2.12 多表连接查询	591
13.2.13 子查询	595
13.2.14 集合运算	596
13.3 jdbc的典型用法	597
13.3.1 jdbc常用接口和类简介	598
13.3.2 jdbc编程步骤	599
前面给出的仅仅是mysql和oracle两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他数据库，那怎么找到其他数据的驱动类呢？	600
13.4 执行sql语句的方式	602
13.4.1 使用executeupdate方法执行ddl和dml语句	602
13.4.2 使用execute方法执行sql语句	604
13.4.3 使用preparedstatement执行sql语句	605
13.4.4 使用callablestatement调用存储过程	609
13.5 管理结果集	611
13.5.1 可滚动、可更新的结果集	611
13.5.2 处理blob类型数据	613
13.5.3 使用resultsetmetadata分析结果集	617
13.6 java 7的rowset 1.1	620
13.6.1 java 7新增的rowsetfactory与rowset	620
13.6.2 离线rowset	623
13.6.3 离线rowset的查询分页	624
13.7 事务处理	625
13.7.1 事务的概念和mysql事务支持	626
13.7.2 jdbc的事务支持	627
13.7.3 批量更新	629
13.8 分析数据库信息	630
13.8.1 使用databasemetadata分析数据库信息	630
13.8.2 使用系统表分析数据库信息	632
13.8.3 选择合适的分析方式	633
13.9 使用连接池管理连接	633
13.9.1 dbcp数据源	634
13.9.2 c3p0数据源	634
13.10 本章小结	635
本章练习	635
第14章 annotation(注释)	636
14.1 基本annotation	637
14.1.1 限定重写父类方法：@override	637
14.1.2 标示已过时：@deprecated	638
14.1.3 抑制编译器警告：@suppresswarnings	639
14.1.4 java 7的“堆污染”警告与@safevarargs	639
14.2 jdk的元annotation	640
14.2.1 使用@retention	640
14.2.2 使用@target	641
14.2.3 使用@documented	641
14.2.4 使用@inherited	642
14.3 自定义annotation	643
14.3.1 定义annotation	643
14.3.2 提取annotation信息	645
14.3.3 使用annotation的示例	646
14.4 编译时处理annotation	650
14.5 本章小结	654
第15章 输入/输出	655
15.1 file类	656
15.1.1 访问文件和目录	656
15.1.2 文件过滤器	658
15.2 理解java的io流	659
15.2.1 流的分类	659
15.2.2 流的概念模型	660
15.3 字节流和字符流	661
15.3.1 inputstream和reader	661
15.3.2 outputstream和writer	663
15.4 输入/输出流体系	665
15.4.1 处理流的用法	665
15.4.2 输入/输出流体系	666
15.4.3 转换流	668
怎么没有把字符流转换成字节流的转换流呢？	668
15.4.4 推回输入流	669
15.5 重定向标准输入/输出	671
15.6 java虚拟机读写其他进程的数据	672
15.7 randomaccessfile	674
15.8 对象序列化	677
15.8.1 序列化的含义和意义	677
15.8.2 使用对象流实现序列化	678
15.8.3 对象引用的序列化	680
15.8.4 自定义序列化	683
15.8.5 另一种自定义序列化机制	688
15.8.6 版本	690
15.9 nio	691
15.9.1 java新io概述	691
15.9.2 使用buffer	691
15.9.3 使用channel	694
15.9.4 字符集和charset	697
二进制序列与字符之间如何对应呢？	698
15.9.5 文件锁	699
15.10 java 7的nio.2	701
15.10.1 path、paths和files核心api	701
15.10.2 使用filevisitor遍历文件和目录	702
15.10.3 使用watchservice监控文件变化	704
15.10.4 访问文件属性	705
15.11 本章小结	706
本章练习	706
第16章 多线程	707
16.1 线程概述	708
16.1.1 线程和进程	708
16.1.2 多线程的优势	709
16.2 线程的创建和启动	710
16.2.1 继承thread类创建线程类	710
16.2.2 实现runnable接口创建线程类	711
16.2.3 使用callable和future创建线程	713
16.2.4 创建线程的三种方式对比	714
16.3 线程的生命周期	715
16.3.1 新建和就绪状态	715
16.3.2 运行和阻塞状态	716
16.3.3 线程死亡	717
16.4 控制线程	718
16.4.1 join线程	719
16.4.2 后台线程	720
16.4.3 线程睡眠：sleep	721
16.4.4 线程让步：yield	721
16.4.5 改变线程优先级	722
16.5 线程同步	724
16.5.1 线程安全问题	724
16.5.2 同步代码块	726
16.5.3 同步方法	727
16.5.4 释放同步监视器的锁定	729
16.5.5 同步锁(lock)	730
16.5.6 死锁	732
16.6 线程通信	733
16.6.1 传统的线程通信	734
16.6.2 使用condition控制线程通信	737
16.6.3 使用阻塞队列(blockingqueue)控制线程通信	739
16.7 线程组和未处理的异常	742
16.8 线程池	744
16.8.1 java 5实现的线程池	745
16.8.2 java 7新增的forkjoinpool	746
16.9 线程相关类	750
16.9.1 threadlocal类	750
16.9.2 包装线程不安全的集合	752
16.9.3 线程安全的集合类	752
16.10 本章小结	753
第17章 网络编程	754
17.1 网络编程的基础知识	755
17.1.1 网络基础知识	755
17.1.2 ip地址和端口号	756
17.2 java的基本网络支持	757
17.2.1 使用inetaddress	757
17.2.2 使用urldecoder和urlencoder	758
17.2.3 使用url和urlconnection	759
17.3 基于tcp协议的网络编程	765
17.3.1 tcp协议基础	765
17.3.2 使用serversocket创建tcp服务器端	766
17.3.3 使用socket进行通信	767
17.3.4 加入多线程	769
17.3.5 记录用户信息	772
17.3.6 半关闭的socket	779
17.3.7 使用nio实现非阻塞socket通信	780
17.3.8 使用java 7的aio实现非阻塞通信	786
上面程序中好像没用到④⑤号代码的get()方法的返回值，这两个地方不调用get()方法行吗？	789
17.4 基于udp协议的网络编程	793
17.4.1 udp协议基础	793
17.4.2 使用datagramsocket发送、接收数据	793
17.4.3 使用multicastsocket实现多点广播	797
17.5 使用代理服务器	807
17.5.1 直接使用proxy创建连接	808
17.5.2 使用proxyselector自动选择代理服务器	809
17.6 本章小结	811
本章练习	811
第18章 类加载机制与反射	812
18.1 类的加载、连接和初始化	813
18.1.1 jvm和类	813
18.1.2 类的加载	814
18.1.3 类的连接	815
18.1.4 类的初始化	815
18.1.5 类初始化的时机	816
18.2 类加载器	817
18.2.1 类加载器简介	817
18.2.2 类加载机制	818
18.2.3 创建并使用自定义的类加载器	820
18.2.4 urlclassloader类	823
18.3 通过反射查看类信息	824
18.3.1 获得class对象	825
18.3.2 从class中获取信息	825
18.4 使用反射生成并操作对象	829
18.4.1 创建对象	829
18.4.2 调用方法	831
18.4.3 访问属性值	833
18.4.4 操作数组	834
18.5 使用反射生成jdk动态代理	835
18.5.1 使用proxy和invocationhandler创建动态代理	835
18.5.2 动态代理和aop	837
18.6 反射和泛型	841
18.6.1 泛型和class类	841
18.6.2 使用反射来获取泛型信息	843
18.7 本章小结	844
本章练习	844